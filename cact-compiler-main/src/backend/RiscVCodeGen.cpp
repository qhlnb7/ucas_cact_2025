//
// RISC-V代码生成器实现
// Created for CACT Compiler RISC-V Backend
//

#include "../../include/backend/RiscVCodeGen.h"
#include "../../include/mir/GlobalVal.h"
#include "../../include/frontend/Initial.h"
#include <algorithm>
#include <sstream>
#include <cassert>

namespace RiscV {

// 静态成员初始化
int VirtualReg::nextId = 0;

// RegisterAllocator 实现
RegisterAllocator::RegisterAllocator() : stackOffset(0) {
    reset();
}

void RegisterAllocator::reset() {
    intRegUsed.clear();
    floatRegUsed.clear();
    for (auto reg : availableIntRegs) {
        intRegUsed[reg] = false;
    }
    for (auto reg : availableFloatRegs) {
        floatRegUsed[reg] = false;
    }
}

Register RegisterAllocator::allocateIntReg() {
    for (auto reg : availableIntRegs) {
        if (!intRegUsed[reg]) {
            intRegUsed[reg] = true;
            return reg;
        }
    }
    return Register::ZERO; // 无可用寄存器，需要溢出
}

Register RegisterAllocator::allocateFloatReg() {
    for (auto reg : availableFloatRegs) {
        if (!floatRegUsed[reg]) {
            floatRegUsed[reg] = true;
            return reg;
        }
    }
    return Register::FT0; // 无可用寄存器，需要溢出
}

void RegisterAllocator::freeReg(Register reg) {
    if (intRegUsed.count(reg)) {
        intRegUsed[reg] = false;
    }
    if (floatRegUsed.count(reg)) {
        floatRegUsed[reg] = false;
    }
}

int RegisterAllocator::allocateStack(int size) {
    stackOffset += size;
    return stackOffset;
}

// RiscVCodeGen 实现
RiscVCodeGen::RiscVCodeGen(Manager* mgr) 
    : manager(mgr), currentFunction(nullptr), currentFunctionStackSize(0), nextLabelId(0) {}

void RiscVCodeGen::generateCode() {
    // 生成全局变量
    generateGlobals();
    
    // 生成外部函数声明
    emitInstr(std::make_shared<RiscVInstr>(InstrType::NOP));
    
    // 生成所有用户定义函数
    auto functions = manager->getFunctionList();
    for (Function* func : *functions) {
        if (func->hasBody()) {
            generateFunction(func);
        }
    }
}

void RiscVCodeGen::outputAssembly(const std::string& filename) {
    std::ofstream file(filename);
    outputAssembly(file);
    file.close();
}

void RiscVCodeGen::outputAssembly(std::ostream& stream) {
    // 输出汇编头部
    stream << "# RISC-V Assembly Generated by CACT Compiler\n";
    stream << ".text\n";
    stream << ".align 2\n\n";
    
    // 输出所有指令
    for (auto& instr : instructions) {
        if (instr->isLabel()) {
            auto labelInstr = dynamic_cast<LabelInstr*>(instr.get());
            if (labelInstr) {
                stream << labelInstr->toString() << "\n";
            }
        } else {
            stream << instr->toString() << "\n";
        }
    }
}

void RiscVCodeGen::generateFunction(Function* func) {
    currentFunction = func;
    regAlloc.reset();
    valueToVReg.clear();
    
    // 计算栈帧大小
    calculateStackFrame(func);
    
    // 生成函数标签
    emitLabel(func->getName());
    
    // 生成函数序言
    generateFunctionPrologue(func);
    
    // 为函数参数分配寄存器/栈位置
    int intArgIndex = 0;
    int floatArgIndex = 0;
    for (auto param : *func->params) {
        if (isFloatType(param->type)) {
            if (floatArgIndex < CallingConvention::MAX_FLOAT_ARGS) {
                Register argReg = CallingConvention::getFloatArgReg(floatArgIndex);
                auto vReg = getOrCreateVReg(param);
                vReg->setPhysicalReg(argReg);
                floatArgIndex++;
            } else {
                // 参数在栈上
                auto vReg = getOrCreateVReg(param);
                int offset = (floatArgIndex - CallingConvention::MAX_FLOAT_ARGS) * 4;
                vReg->setSpilled(offset);
            }
        } else {
            if (intArgIndex < CallingConvention::MAX_INT_ARGS) {
                Register argReg = CallingConvention::getIntArgReg(intArgIndex);
                auto vReg = getOrCreateVReg(param);
                vReg->setPhysicalReg(argReg);
                intArgIndex++;
            } else {
                // 参数在栈上
                auto vReg = getOrCreateVReg(param);
                int offset = (intArgIndex - CallingConvention::MAX_INT_ARGS) * 4;
                vReg->setSpilled(offset);
            }
        }
    }
    
    // 生成基本块代码
    for (BasicBlock* bb = (BasicBlock*)func->begin->next; bb->next != nullptr; bb = (BasicBlock*)bb->next) {
        generateBasicBlock(bb);
    }
    
    // 生成函数尾声
    generateFunctionEpilogue(func);
    
    currentFunction = nullptr;
}

void RiscVCodeGen::generateFunctionPrologue(Function* func) {
    // 保存ra寄存器
    emitInstr(std::make_shared<ITypeInstr>(InstrType::ADDI, Register::SP, Register::SP, -currentFunctionStackSize));
    emitInstr(std::make_shared<STypeInstr>(InstrType::SW, Register::RA, currentFunctionStackSize - 4, Register::SP));
    emitInstr(std::make_shared<STypeInstr>(InstrType::SW, Register::S0, currentFunctionStackSize - 8, Register::SP));
    emitInstr(std::make_shared<ITypeInstr>(InstrType::ADDI, Register::S0, Register::SP, currentFunctionStackSize));
}

void RiscVCodeGen::generateFunctionEpilogue(Function* func) {
    // 恢复寄存器
    emitInstr(std::make_shared<ITypeInstr>(InstrType::LW, Register::RA, Register::SP, currentFunctionStackSize - 4));
    emitInstr(std::make_shared<ITypeInstr>(InstrType::LW, Register::S0, Register::SP, currentFunctionStackSize - 8));
    emitInstr(std::make_shared<ITypeInstr>(InstrType::ADDI, Register::SP, Register::SP, currentFunctionStackSize));
    emitInstr(std::make_shared<RiscVInstr>(InstrType::RET));
}

void RiscVCodeGen::generateBasicBlock(BasicBlock* bb) {
    // 生成基本块标签
    if (bb != currentFunction->entry) {
        emitLabel(bb->label);
    }
    
    // 生成基本块中的指令
    for (Instr* instr = (Instr*)bb->begin->next; instr->next != nullptr; instr = (Instr*)instr->next) {
        generateInstruction(instr);
    }
}

void RiscVCodeGen::generateInstruction(Instr* instr) {
    // 根据指令类型分发到具体的生成函数
    if (auto alu = dynamic_cast<INSTR::Alu*>(instr)) {
        generateAlu(alu);
    } else if (auto icmp = dynamic_cast<INSTR::Icmp*>(instr)) {
        generateIcmp(icmp);
    } else if (auto fcmp = dynamic_cast<INSTR::Fcmp*>(instr)) {
        generateFcmp(fcmp);
    } else if (auto zext = dynamic_cast<INSTR::Zext*>(instr)) {
        generateZext(zext);
    } else if (auto fptosi = dynamic_cast<INSTR::FPtosi*>(instr)) {
        generateFPtosi(fptosi);
    } else if (auto sitofp = dynamic_cast<INSTR::SItofp*>(instr)) {
        generateSItofp(sitofp);
    } else if (auto alloc = dynamic_cast<INSTR::Alloc*>(instr)) {
        generateAlloc(alloc);
    } else if (auto load = dynamic_cast<INSTR::Load*>(instr)) {
        generateLoad(load);
    } else if (auto store = dynamic_cast<INSTR::Store*>(instr)) {
        generateStore(store);
    } else if (auto gep = dynamic_cast<INSTR::GetElementPtr*>(instr)) {
        generateGetElementPtr(gep);
    } else if (auto call = dynamic_cast<INSTR::Call*>(instr)) {
        generateCall(call);
    } else if (auto phi = dynamic_cast<INSTR::Phi*>(instr)) {
        generatePhi(phi);
    } else if (auto branch = dynamic_cast<INSTR::Branch*>(instr)) {
        generateBranch(branch);
    } else if (auto jump = dynamic_cast<INSTR::Jump*>(instr)) {
        generateJump(jump);
    } else if (auto ret = dynamic_cast<INSTR::Return*>(instr)) {
        generateReturn(ret);
    }
}

void RiscVCodeGen::generateAlu(INSTR::Alu* alu) {
    Register dest = getPhysicalReg(alu);
    Register src1 = getPhysicalReg(alu->getRVal1());
    Register src2 = getPhysicalReg(alu->getRVal2());
    
    // 根据操作类型生成相应的RISC-V指令
    switch (alu->op) {
        case INSTR::Alu::Op::ADD:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::ADD, dest, src1, src2));
            break;
        case INSTR::Alu::Op::FADD:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::FADD_S, dest, src1, src2));
            break;
        case INSTR::Alu::Op::SUB:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::SUB, dest, src1, src2));
            break;
        case INSTR::Alu::Op::FSUB:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::FSUB_S, dest, src1, src2));
            break;
        case INSTR::Alu::Op::MUL:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::MUL, dest, src1, src2));
            break;
        case INSTR::Alu::Op::FMUL:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::FMUL_S, dest, src1, src2));
            break;
        case INSTR::Alu::Op::DIV:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::DIV, dest, src1, src2));
            break;
        case INSTR::Alu::Op::FDIV:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::FDIV_S, dest, src1, src2));
            break;
        case INSTR::Alu::Op::REM:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::REM, dest, src1, src2));
            break;
        case INSTR::Alu::Op::AND:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::AND, dest, src1, src2));
            break;
        case INSTR::Alu::Op::OR:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::OR, dest, src1, src2));
            break;
        case INSTR::Alu::Op::XOR:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::XOR, dest, src1, src2));
            break;
        case INSTR::Alu::Op::SHL:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::SLL, dest, src1, src2));
            break;
        case INSTR::Alu::Op::LSHR:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::SRL, dest, src1, src2));
            break;
        case INSTR::Alu::Op::ASHR:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::SRA, dest, src1, src2));
            break;
        default:
            assert(false && "Unsupported ALU operation");
    }
}

void RiscVCodeGen::generateIcmp(INSTR::Icmp* icmp) {
    Register dest = getPhysicalReg(icmp);
    Register src1 = getPhysicalReg(icmp->getRVal1());
    Register src2 = getPhysicalReg(icmp->getRVal2());
    
    switch (icmp->op) {
        case INSTR::Icmp::Op::EQ:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::XOR, dest, src1, src2));
            emitInstr(std::make_shared<ITypeInstr>(InstrType::SLTIU, dest, dest, 1));
            break;
        case INSTR::Icmp::Op::NE:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::XOR, dest, src1, src2));
            emitInstr(std::make_shared<RTypeInstr>(InstrType::SLTU, dest, Register::ZERO, dest));
            break;
        case INSTR::Icmp::Op::SGT:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::SLT, dest, src2, src1));
            break;
        case INSTR::Icmp::Op::SGE:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::SLT, dest, src1, src2));
            emitInstr(std::make_shared<ITypeInstr>(InstrType::XORI, dest, dest, 1));
            break;
        case INSTR::Icmp::Op::SLT:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::SLT, dest, src1, src2));
            break;
        case INSTR::Icmp::Op::SLE:
            emitInstr(std::make_shared<RTypeInstr>(InstrType::SLT, dest, src2, src1));
            emitInstr(std::make_shared<ITypeInstr>(InstrType::XORI, dest, dest, 1));
            break;
        default:
            assert(false && "Unsupported icmp operation");
    }
}

void RiscVCodeGen::generateLoad(INSTR::Load* load) {
    Register dest = getPhysicalReg(load);
    Register ptr = getPhysicalReg(load->getPointer());
    
    InstrType loadInstr = getLoadInstr(load->type);
    emitInstr(std::make_shared<ITypeInstr>(loadInstr, dest, ptr, 0));
}

void RiscVCodeGen::generateStore(INSTR::Store* store) {
    Register src = getPhysicalReg(store->getValue());
    Register ptr = getPhysicalReg(store->getPointer());
    
    InstrType storeInstr = getStoreInstr(store->getValue()->type);
    emitInstr(std::make_shared<STypeInstr>(storeInstr, src, 0, ptr));
}

void RiscVCodeGen::generateReturn(INSTR::Return* ret) {
    if (!ret->useValueList.empty()) {
        // 有返回值
        Register retReg = getPhysicalReg(ret->getRetValue());
        if (isFloatType(ret->getRetValue()->type)) {
            if (retReg != Register::FA0) {
                emitInstr(std::make_shared<RTypeInstr>(InstrType::MV, Register::FA0, retReg));
            }
        } else {
            if (retReg != Register::A0) {
                emitInstr(std::make_shared<RTypeInstr>(InstrType::MV, Register::A0, retReg));
            }
        }
    }
    
    // 跳转到函数尾声
    std::string epilogueLabel = currentFunction->getName() + "_epilogue";
    emitInstr(std::make_shared<JTypeInstr>(InstrType::J, epilogueLabel));
}

// 工具方法实现
std::shared_ptr<VirtualReg> RiscVCodeGen::getOrCreateVReg(Value* value) {
    if (valueToVReg.find(value) == valueToVReg.end()) {
        valueToVReg[value] = std::make_shared<VirtualReg>(value->type);
    }
    return valueToVReg[value];
}

Register RiscVCodeGen::getPhysicalReg(Value* value) {
    // 处理常量
    if (auto constant = dynamic_cast<ConstantInt*>(value)) {
        Register tempReg = regAlloc.allocateIntReg();
        loadConstant(tempReg, constant->get_const_val());
        return tempReg;
    }
    if (auto constant = dynamic_cast<ConstantFloat*>(value)) {
        Register tempReg = regAlloc.allocateFloatReg();
        loadConstant(tempReg, constant->get_const_val());
        return tempReg;
    }
    
    auto vReg = getOrCreateVReg(value);
    if (vReg->isSpilled()) {
        // 从栈中加载
        Register tempReg = isFloatType(value->type) ? regAlloc.allocateFloatReg() : regAlloc.allocateIntReg();
        loadFromMemory(tempReg, Register::SP, vReg->getStackOffset(), value->type);
        return tempReg;
    } else {
        if (vReg->getPhysicalReg() == Register::ZERO) {
            // 分配物理寄存器
            Register physReg = isFloatType(value->type) ? regAlloc.allocateFloatReg() : regAlloc.allocateIntReg();
            vReg->setPhysicalReg(physReg);
        }
        return vReg->getPhysicalReg();
    }
}

void RiscVCodeGen::emitInstr(std::shared_ptr<RiscVInstr> instr) {
    instructions.push_back(instr);
}

void RiscVCodeGen::emitLabel(const std::string& label) {
    instructions.push_back(std::make_shared<LabelInstr>(label));
}

bool RiscVCodeGen::isFloatType(Type* type) {
    return type->is_float_type();
}

int RiscVCodeGen::getTypeSize(Type* type) {
    if (type->is_int32_type() || type->is_float_type()) {
        return 4;
    }
    if (type->is_int1_type()) {
        return 1;
    }
    return 4; // 默认
}

RiscV::InstrType RiscVCodeGen::getLoadInstr(Type* type) {
    if (type->is_float_type()) {
        return InstrType::FLW;
    } else if (type->is_int1_type()) {
        return InstrType::LB;
    } else {
        return InstrType::LW;
    }
}

RiscV::InstrType RiscVCodeGen::getStoreInstr(Type* type) {
    if (type->is_float_type()) {
        return InstrType::FSW;
    } else if (type->is_int1_type()) {
        return InstrType::SB;
    } else {
        return InstrType::SW;
    }
}

void RiscVCodeGen::loadConstant(Register dest, int value) {
    if (value >= -2048 && value <= 2047) {
        emitInstr(std::make_shared<ITypeInstr>(InstrType::ADDI, dest, Register::ZERO, value));
    } else {
        handleLargeImmediate(dest, value);
    }
}

void RiscVCodeGen::handleLargeImmediate(Register dest, int value) {
    // 对于大立即数，使用lui + addi
    int upper = (value + 0x800) >> 12;
    int lower = value - (upper << 12);
    
    emitInstr(std::make_shared<UTypeInstr>(InstrType::LI, dest, upper));
    if (lower != 0) {
        emitInstr(std::make_shared<ITypeInstr>(InstrType::ADDI, dest, dest, lower));
    }
}

void RiscVCodeGen::loadFromMemory(Register dest, Register base, int offset, Type* type) {
    InstrType loadInstr = getLoadInstr(type);
    emitInstr(std::make_shared<ITypeInstr>(loadInstr, dest, base, offset));
}

void RiscVCodeGen::storeToMemory(Register src, Register base, int offset, Type* type) {
    InstrType storeInstr = getStoreInstr(type);
    emitInstr(std::make_shared<STypeInstr>(storeInstr, src, offset, base));
}

void RiscVCodeGen::calculateStackFrame(Function* func) {
    // 简单的栈帧计算：为所有局部变量分配空间
    currentFunctionStackSize = 16; // 基础空间：ra + s0
    
    // 为每个需要栈空间的变量分配空间
    // 这里简化处理，实际应该根据具体需求计算
    currentFunctionStackSize += func->params->size() * 4;
    
    // 对齐到16字节
    currentFunctionStackSize = (currentFunctionStackSize + 15) & ~15;
}

// 部分函数实现占位符，需要后续完善
void RiscVCodeGen::generateFcmp(INSTR::Fcmp* fcmp) {
    // TODO: 实现浮点比较
}

void RiscVCodeGen::generateZext(INSTR::Zext* zext) {
    // TODO: 实现零扩展
}

void RiscVCodeGen::generateFPtosi(INSTR::FPtosi* fptosi) {
    // TODO: 实现浮点到整数转换
}

void RiscVCodeGen::generateSItofp(INSTR::SItofp* sitofp) {
    // TODO: 实现整数到浮点转换
}

void RiscVCodeGen::generateAlloc(INSTR::Alloc* alloc) {
    // TODO: 实现栈分配
}

void RiscVCodeGen::generateGetElementPtr(INSTR::GetElementPtr* gep) {
    // TODO: 实现GEP指令
}

void RiscVCodeGen::generateCall(INSTR::Call* call) {
    // TODO: 实现函数调用
}

void RiscVCodeGen::generatePhi(INSTR::Phi* phi) {
    // TODO: 实现Phi指令
}

void RiscVCodeGen::generateBranch(INSTR::Branch* branch) {
    // TODO: 实现条件分支
}

void RiscVCodeGen::generateJump(INSTR::Jump* jump) {
    // TODO: 实现无条件跳转
}

void RiscVCodeGen::generateGlobals() {
    // TODO: 实现全局变量生成
}

void RiscVCodeGen::generateGlobalVariable(GlobalValue* global, Initial* init) {
    // TODO: 实现单个全局变量生成
}

void RiscVCodeGen::loadConstant(Register dest, float value) {
    // TODO: 实现浮点常量加载
}

void RiscVCodeGen::loadGlobalAddress(Register dest, const std::string& global) {
    // TODO: 实现全局地址加载
}

std::string RiscVCodeGen::getUniqueLabel(const std::string& prefix) {
    return prefix + "_" + std::to_string(nextLabelId++);
}

bool RiscVCodeGen::canUseImmediate(int value) {
    return value >= -2048 && value <= 2047;
}

int RiscVCodeGen::getStackOffset(Value* value) {
    auto vReg = getOrCreateVReg(value);
    return vReg->getStackOffset();
}

void RiscVCodeGen::spillRegister(Register reg) {
    // TODO: 实现寄存器溢出
}

void RiscVCodeGen::restoreRegister(Register reg) {
    // TODO: 实现寄存器恢复
}

void RiscVCodeGen::saveCallerSavedRegs() {
    // TODO: 实现调用者保存寄存器
}

void RiscVCodeGen::restoreCallerSavedRegs() {
    // TODO: 实现调用者恢复寄存器
}

} // namespace RiscV 